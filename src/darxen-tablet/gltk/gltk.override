/* vim: set filetype=c : */
%%
headers
#include <Python.h>
#include "pygobject.h"
#include "gltk.h"
%%
modulename gltk
%%
import gobject.GObject as PyGObject_Type
import gobject.GObject as PyGInitiallyUnowned_Type
%%
ignore-glob
  *_get_type
  *_error_quark
%%
ignore
  gltk_accum_event
%%
ignore-type
  GltkBinError
  GltkBoxError
  GltkButtonError
  GltkDialogError
  GltkEntryError
  GltkHBoxError
  GltkKeyboardError
  GltkLabelError
  GltkListError
  GltkMiniScreenError
  GltkScreenError
  GltkScrollableError
  GltkSlideButtonError
  GltkSpinnerError
  GltkSpinnerModelError
  GltkToggleButtonError
  GltkVBoxError
  GltkWidgetError
  GltkWindowError
%%
new-constructor GLTK_TYPE_WINDOW
%%
override gltk_window_new kwargs
static int
_wrap_gltk_window_new(PyGObject *self, PyObject *args, PyObject *kwargs)
{
    self->obj = (GObject *)gltk_window_new();

    if (!self->obj) {
        PyErr_SetString(PyExc_RuntimeError, "could not create GltkWindow object");
        return -1;
    }
    pygobject_register_wrapper((PyObject *)self);
    return 0;
}
/*%%
override gltk_event_for_mouse
static PyObject*
_wrap_gltk_event_for_mouse(PyObject *self, PyObject *args, PyObject *kwargs)
{
	GltkEvent event;

	//PyArg_ParseTuple(args, "i(ii)", 
	if (!PyArg_ParseTuple(args, "i", &event.touch.fingers))
		return -1;

	self->boxed = g_boxed_copy(GLTK_TYPE_EVENT, &event);

	
}*/




%%
override-slot GltkEvent.tp_getattr
static PyObject *
_wrap_gltk_event_tp_getattr(PyObject *self, char *attr)
{
    GltkEvent *event = pyg_boxed_get(self, GltkEvent);
    guint i;

    switch(event->type) {
    case GLTK_TOUCH:
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[sssss]",
                                 "type", "id", "touchType",
                                 "fingers", "positions");
        if (!strcmp(attr, "id"))
            return PyInt_FromLong(event->touch.id);
		if (!strcmp(attr, "touchType"))
			return pyg_enum_from_gtype(GLTK_TYPE_TOUCH_EVENT_TYPE, event->touch.touchType);
        if (!strcmp(attr, "fingers"))
            return PyInt_FromLong(event->touch.fingers);
		if (!strcmp(attr, "positions")) {
			if (event->touch.positions) {
				PyObject *v = PyTuple_New(event->touch.fingers);
				if (!v) return NULL;
				for (i = 0; i < event->touch.fingers; i++)
					PyTuple_SetItem(v, i, Py_BuildValue("(ii)", event->touch.positions[i].x,
															   	event->touch.positions[i].y));
				return v;
			} else {
				Py_INCREF(Py_None);
				return Py_None;
			}
		}
        break;
	case GLTK_LONG_TOUCH:
	case GLTK_CLICK:
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[s]", "type");
		break;
	case GLTK_DRAG:
	case GLTK_MULTI_DRAG:
	case GLTK_PINCH:
	case GLTK_ROTATE:
	case GLTK_SLIDE:
		//FIXME These should not be opaque
        if (!strcmp(attr, "__members__"))
            return Py_BuildValue("[s]", "type");
		break;
	
    default:
        break;
    }
    
    if (!strcmp(attr, "type"))
        return pyg_enum_from_gtype(GLTK_TYPE_EVENT_TYPE, event->type);
    if (!strcmp(attr, "__members__"))
        return Py_BuildValue("[sss]", "type");

    return Py_FindMethod((PyMethodDef*)_PyGltkEvent_methods, self, attr);
}








